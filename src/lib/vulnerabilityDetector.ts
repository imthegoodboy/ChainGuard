export type Vulnerability = {
  severity: 'critical' | 'high' | 'medium' | 'low';
  category: string;
  description: string;
  location: string;
  recommendation: string;
  codeSnippet?: string;
};

export type ScanResult = {
  vulnerabilities: Vulnerability[];
  riskScore: number;
  scanDuration: number;
};

const vulnerabilityPatterns = [
  {
    pattern: /\.call\s*\{/g,
    severity: 'high' as const,
    category: 'Reentrancy',
    description: 'Potential reentrancy vulnerability detected. Using .call{} without proper checks can allow attackers to repeatedly call back into your contract.',
    recommendation: 'Use the Checks-Effects-Interactions pattern. Update state variables before making external calls, or use a reentrancy guard modifier.',
  },
  {
    pattern: /\.transfer\s*\(/g,
    severity: 'medium' as const,
    category: 'Gas Limit',
    description: 'Using .transfer() which has a fixed gas stipend of 2300. This can fail with contract wallets and multi-sig wallets.',
    recommendation: 'Use .call{value: amount}("") instead of .transfer() for more robust fund transfers.',
  },
  {
    pattern: /tx\.origin/g,
    severity: 'critical' as const,
    category: 'Authentication',
    description: 'Using tx.origin for authentication is dangerous. It can be exploited through phishing attacks where users are tricked into calling malicious contracts.',
    recommendation: 'Use msg.sender instead of tx.origin for authentication checks.',
  },
  {
    pattern: /selfdestruct\s*\(/g,
    severity: 'high' as const,
    category: 'Contract Destruction',
    description: 'selfdestruct can permanently destroy your contract and send all funds to an address. If not properly protected, attackers could destroy your contract.',
    recommendation: 'Ensure selfdestruct is protected by proper access controls and consider if it\'s truly necessary.',
  },
  {
    pattern: /delegatecall\s*\(/g,
    severity: 'critical' as const,
    category: 'Delegate Call',
    description: 'delegatecall executes code in the context of the calling contract. If used with untrusted contracts, it can allow complete takeover of your contract.',
    recommendation: 'Only use delegatecall with trusted, verified contracts. Implement strict access controls and validate all delegatecall targets.',
  },
  {
    pattern: /block\.timestamp/g,
    severity: 'low' as const,
    category: 'Timestamp Dependence',
    description: 'Relying on block.timestamp can be manipulated by miners within a small range (~15 seconds). This could affect time-dependent logic.',
    recommendation: 'Avoid using block.timestamp for critical logic. If necessary, use it with sufficient tolerance margins.',
  },
  {
    pattern: /private\s+\w+\s*;/g,
    severity: 'low' as const,
    category: 'Data Privacy',
    description: 'Variables marked as private are not truly private. All data on the blockchain is publicly visible.',
    recommendation: 'Never store sensitive data like passwords or private keys in contract variables, even if marked private.',
  },
  {
    pattern: /unchecked\s*\{/g,
    severity: 'medium' as const,
    category: 'Arithmetic',
    description: 'Unchecked arithmetic blocks bypass overflow/underflow protection. This can lead to unexpected behavior if not carefully managed.',
    recommendation: 'Only use unchecked blocks when you are absolutely certain overflow/underflow cannot occur, or when it\'s intentional.',
  },
];

const additionalChecks = [
  {
    check: (code: string) => !code.includes('pragma solidity'),
    severity: 'medium' as const,
    category: 'Compiler Version',
    description: 'No Solidity version pragma found. This can lead to compilation with unintended compiler versions.',
    location: 'File header',
    recommendation: 'Always specify a Solidity version pragma, e.g., "pragma solidity ^0.8.0;"',
  },
  {
    check: (code: string) => code.includes('public') && !code.includes('external'),
    severity: 'low' as const,
    category: 'Gas Optimization',
    description: 'Using public functions when external would suffice wastes gas. External functions are cheaper for external calls.',
    location: 'Function declarations',
    recommendation: 'Use external visibility for functions that are only called externally to save gas.',
  },
  {
    check: (code: string) => !code.includes('ReentrancyGuard') && code.includes('.call{'),
    severity: 'high' as const,
    category: 'Missing Protection',
    description: 'Contract uses .call{} without implementing reentrancy protection. This is a common attack vector.',
    location: 'Contract structure',
    recommendation: 'Import and use OpenZeppelin\'s ReentrancyGuard for functions making external calls.',
  },
  {
    check: (code: string) => code.includes('owner') && !code.includes('onlyOwner') && !code.includes('Ownable'),
    severity: 'medium' as const,
    category: 'Access Control',
    description: 'Contract appears to have an owner but lacks proper access control modifiers or patterns.',
    location: 'Access control',
    recommendation: 'Implement OpenZeppelin\'s Ownable pattern or create an onlyOwner modifier for privileged functions.',
  },
];

const findLineNumber = (code: string, index: number): number => {
  return code.substring(0, index).split('\n').length;
};

const getCodeSnippet = (code: string, lineNumber: number): string => {
  const lines = code.split('\n');
  const start = Math.max(0, lineNumber - 2);
  const end = Math.min(lines.length, lineNumber + 1);
  return lines.slice(start, end).join('\n');
};

export const analyzeContract = async (code: string): Promise<ScanResult> => {
  const startTime = Date.now();
  const vulnerabilities: Vulnerability[] = [];

  for (const pattern of vulnerabilityPatterns) {
    const matches = code.matchAll(pattern.pattern);
    for (const match of matches) {
      const lineNumber = findLineNumber(code, match.index || 0);
      vulnerabilities.push({
        severity: pattern.severity,
        category: pattern.category,
        description: pattern.description,
        location: `Line ${lineNumber}`,
        recommendation: pattern.recommendation,
        codeSnippet: getCodeSnippet(code, lineNumber),
      });
    }
  }

  for (const check of additionalChecks) {
    if (check.check(code)) {
      vulnerabilities.push({
        severity: check.severity,
        category: check.category,
        description: check.description,
        location: check.location,
        recommendation: check.recommendation,
      });
    }
  }

  const riskScore = calculateRiskScore(vulnerabilities);
  const scanDuration = Date.now() - startTime;

  await new Promise(resolve => setTimeout(resolve, 1500));

  return {
    vulnerabilities,
    riskScore,
    scanDuration: scanDuration + 1500,
  };
};

const calculateRiskScore = (vulnerabilities: Vulnerability[]): number => {
  const severityWeights = {
    critical: 40,
    high: 25,
    medium: 15,
    low: 5,
  };

  let totalScore = 0;
  for (const vuln of vulnerabilities) {
    totalScore += severityWeights[vuln.severity];
  }

  return Math.min(100, totalScore);
};

export const fetchGitHubContract = async (url: string): Promise<string> => {
  try {
    let rawUrl = url;

    if (url.includes('github.com') && !url.includes('raw.githubusercontent.com')) {
      rawUrl = url
        .replace('github.com', 'raw.githubusercontent.com')
        .replace('/blob/', '/');
    }

    const response = await fetch(rawUrl);
    if (!response.ok) {
      throw new Error('Failed to fetch contract from GitHub');
    }

    return await response.text();
  } catch (error) {
    throw new Error('Invalid GitHub URL or file not accessible');
  }
};
